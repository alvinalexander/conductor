{"version":3,"sources":["components/VideoFrame.js","components/App.js","components/Root.js","serviceWorker.js","index.js"],"names":["tfjsWasm","version","videoWidth","videoHeight","fingerLookupIndices","thumb","indexFinger","middleFinger","ringFinger","pinky","VideoFrame","props","state","backend","videoRef","React","createRef","canvasRef","styles","position","top","left","ctx","y","x","r","beginPath","arc","Math","PI","fill","keypoints","keypointsArray","i","length","this","drawPoint","fingers","Object","keys","finger","points","map","idx","drawPath","closePath","region","Path2D","moveTo","point","lineTo","stroke","navigator","mediaDevices","getUserMedia","Error","video","current","facingMode","width","height","stream","srcObject","Promise","resolve","onloadedmetadata","setupCamera","play","tf","handpose","model","setState","loadVideo","info","document","getElementById","textContent","message","style","display","landmarksRealTime","stats","Stats","showPanel","body","appendChild","dom","domElement","canvas","getContext","clearRect","strokeStyle","fillStyle","translate","scale","frameLandmarks","a","begin","drawImage","estimateHands","predictions","result","landmarks","drawKeypoints","annotations","end","requestAnimationFrame","font","textBaseline","forEach","prediction","bbox","lineWidth","strokeRect","textWidth","measureText","class","textHeight","parseInt","fillRect","fillText","score","toFixed","autoPlay","muted","ref","Component","App","className","Root","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","serviceWorker","ready","then","registration","unregister","catch","error","console"],"mappings":"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","file":"static/js/main.295d251b.chunk.js","sourcesContent":["import React from 'react';\nimport * as THREE from 'three';\nimport WebMidi from 'webmidi'\nimport * as handpose from '@tensorflow-models/handpose';\nimport * as tfjsWasm from '@tensorflow/tfjs-backend-wasm';\n// TODO(annxingyuan): read version from tfjsWasm directly once\n// https://github.com/tensorflow/tfjs/pull/2819 is merged.\nimport {version} from '@tensorflow/tfjs-backend-wasm/dist/version';\nimport * as tf from '@tensorflow/tfjs-core';\nimport {ScatterGL} from 'scatter-gl';\nimport Stats from \"stats-js\"\ntfjsWasm.setWasmPath(\n  `https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-wasm@${\n      version}/dist/tfjs-backend-wasm.wasm`);\n\nlet videoWidth, videoHeight,\nscatterGLHasInitialized = false, scatterGL, fingerLookupIndices = {\n  thumb: [0, 1, 2, 3, 4],\n  indexFinger: [0, 5, 6, 7, 8],\n  middleFinger: [0, 9, 10, 11, 12],\n  ringFinger: [0, 13, 14, 15, 16],\n  pinky: [0, 17, 18, 19, 20]\n};  // for rendering each finger as a polyline\n\nconst VIDEO_WIDTH = 640;\nconst VIDEO_HEIGHT = 500;\nconst renderPointcloud = false;\n\nclass VideoFrame extends React.Component {\n\n    constructor(props){\n        super(props);\n        this.state = {\n          backend: 'webgl'\n        }\n        this.videoRef = React.createRef();\n        this.canvasRef = React.createRef();\n        this.styles = {\n            position: 'fixed',\n            top: 150,\n            left: 150,\n        }\n    }\n    \n    drawPoint(ctx, y, x, r) {\n      ctx.beginPath();\n      ctx.arc(x, y, r, 0, 2 * Math.PI);\n      ctx.fill();\n    } \n\n    drawKeypoints(ctx, keypoints) {\n      const keypointsArray = keypoints;\n    \n      for (let i = 0; i < keypointsArray.length; i++) {\n        const y = keypointsArray[i][0];\n        const x = keypointsArray[i][1];\n        this.drawPoint(ctx, x - 2, y - 2, 3);\n      }\n    \n      const fingers = Object.keys(fingerLookupIndices);\n      for (let i = 0; i < fingers.length; i++) {\n        const finger = fingers[i];\n        const points = fingerLookupIndices[finger].map(idx => keypoints[idx]);\n        this.drawPath(ctx, points, false);\n      }\n    }\n\n    drawPath(ctx, points, closePath) {\n    \n      const region = new Path2D();\n      region.moveTo(points[0][0], points[0][1]);\n      for (let i = 1; i < points.length; i++) {\n        const point = points[i];\n        region.lineTo(point[0], point[1]);\n      }\n    \n      if (closePath) {\n        region.closePath();\n      }\n      ctx.stroke(region);\n    }\n\n    async setupCamera() {\n      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {\n        throw new Error(\n            'Browser API navigator.mediaDevices.getUserMedia not available');\n      }\n    \n      const video = this.videoRef.current;\n      const stream = await navigator.mediaDevices.getUserMedia({\n        'audio': false,\n        'video': {\n          facingMode: 'user',\n          // Only setting the video to a specified size in order to accommodate a\n          // point cloud, so on mobile devices accept the default size.\n          width: VIDEO_WIDTH,\n          height: VIDEO_HEIGHT\n        },\n      });\n\n      // window.stream = stream;\n      \n      video.srcObject = stream;\n    \n      return new Promise((resolve) => {\n        video.onloadedmetadata = () => {\n          resolve(video);\n        };\n      });\n    }\n\n    async loadVideo() {\n      const video = await this.setupCamera();\n      video.play();\n      return video;\n    }\n    \n  \n    async componentDidMount(){\n      await tf.setBackend(this.state.backend);\n      const model = await handpose.load();\n      await this.setState({model:model}) // is this async or not\n      let video;\n    \n      try {\n        video = await this.loadVideo();\n      } catch (e) {\n        let info = document.getElementById('info');\n        info.textContent = e.message;\n        info.style.display = 'block';\n        throw e;\n      }\n    \n      this.landmarksRealTime(video);\n    }\n\n    async landmarksRealTime (video) {\n      const {model} = this.state;\n      const stats = new Stats();\n      stats.showPanel(0);\n      document.body.appendChild(stats.dom);\n      stats.domElement.style = {\n        top: 500,\n        left: 500,\n      };\n    \n      videoWidth = video.videoWidth;\n      videoHeight = video.videoHeight;\n    \n      const canvas = this.canvasRef.current;\n    \n      canvas.width = videoWidth;\n      canvas.height = videoHeight;\n    \n      const ctx = canvas.getContext('2d');\n    \n      video.width = videoWidth;\n      video.height = videoHeight;\n    \n      ctx.clearRect(0, 0, videoWidth, videoHeight);\n      ctx.strokeStyle = 'red';\n      ctx.fillStyle = 'red';\n    \n      ctx.translate(canvas.width, 0);\n      ctx.scale(-1, 1);\n    \n      // These anchor points allow the hand pointcloud to resize according to its\n      // position in the input.\n      const ANCHOR_POINTS = [\n        [0, 0, 0], [0, -VIDEO_HEIGHT, 0], [-VIDEO_WIDTH, 0, 0],\n        [-VIDEO_WIDTH, -VIDEO_HEIGHT, 0]\n      ];\n    \n      const frameLandmarks = async () => {\n        stats.begin();\n        ctx.drawImage(\n            video, 0, 0, videoWidth, videoHeight, 0, 0, canvas.width,\n            canvas.height);\n        const predictions = await model.estimateHands(video);\n        if (predictions.length > 0) {\n          const result = predictions[0].landmarks;\n          this.drawKeypoints(ctx, result, predictions[0].annotations);\n    \n          if (renderPointcloud === true && scatterGL != null) {\n            const pointsData = result.map(point => {\n              return [-point[0], -point[1], -point[2]];\n            });\n    \n            const dataset =\n                new ScatterGL.Dataset([...pointsData, ...ANCHOR_POINTS]);\n    \n            if (!scatterGLHasInitialized) {\n              scatterGL.render(dataset);\n    \n              const fingers = Object.keys(fingerLookupIndices);\n    \n              scatterGL.setSequences(\n                  fingers.map(finger => ({indices: fingerLookupIndices[finger]})));\n              scatterGL.setPointColorer((index) => {\n                if (index < pointsData.length) {\n                  return 'steelblue';\n                }\n                return 'white';  // Hide.\n              });\n            } else {\n              scatterGL.updateDataset(dataset);\n            }\n            scatterGLHasInitialized = true;\n          }\n        }\n        stats.end();\n        requestAnimationFrame(frameLandmarks);\n      };\n    \n      frameLandmarks();\n    \n      if (renderPointcloud) {\n        document.querySelector('#scatter-gl-container').style =\n            `width: ${VIDEO_WIDTH}px; height: ${VIDEO_HEIGHT}px;`;\n    \n        scatterGL = new ScatterGL(\n            document.querySelector('#scatter-gl-container'),\n            {'rotateOnStart': false, 'selectEnabled': false});\n      }\n    };\n\n    showDetections(predictions) {\n        const ctx = this.canvasRef.current.getContext(\"2d\");\n        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n        const font = \"24px helvetica\";\n        ctx.font = font;\n        ctx.textBaseline = \"top\";\n    \n        predictions.forEach(prediction => {\n          const x = prediction.bbox[0];\n          const y = prediction.bbox[1];\n          const width = prediction.bbox[2];\n          const height = prediction.bbox[3];\n          // Draw the bounding box.\n          ctx.strokeStyle = \"#2fff00\";\n          ctx.lineWidth = 1;\n          ctx.strokeRect(x, y, width, height);\n          // Draw the label background.\n          ctx.fillStyle = \"#2fff00\";\n          const textWidth = ctx.measureText(prediction.class).width;\n          const textHeight = parseInt(font, 10);\n          // draw top left rectangle\n          ctx.fillRect(x, y, textWidth + 10, textHeight + 10);\n          // draw bottom left rectangle\n          ctx.fillRect(x, y + height - textHeight, textWidth + 15, textHeight + 10);\n    \n          // Draw the text last to ensure it's on top.\n          ctx.fillStyle = \"#000000\";\n          ctx.fillText(prediction.class, x, y);\n          ctx.fillText(prediction.score.toFixed(2), x, y + height - textHeight);\n        });\n      };\n\n\n      render() {\n        return (\n            <div> \n              <video\n                style={this.styles}\n                autoPlay\n                muted\n                ref={this.videoRef}\n                width={VIDEO_WIDTH}\n                height={VIDEO_HEIGHT}\n              />\n              <canvas style={this.styles} ref={this.canvasRef} width={videoWidth} height={videoHeight} />\n            </div>\n          );\n      }\n\n\n}\n\n\nexport default VideoFrame;","import React from 'react';\nimport VideoFrame from './VideoFrame';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <h1>Handpose</h1>\n      <VideoFrame />\n    </div>\n  );\n}\nexport default App;\n","import React from 'react'\nimport App from './App'\n\nconst Root = () => (<App/>);\n\nexport default Root;","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport Root from './components/Root';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <Root />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}